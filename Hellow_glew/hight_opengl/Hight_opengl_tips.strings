/* 
  Hight_opengl_tips.strings
  Hellow_glew

  Created by JFChen on 2018/4/11.
  Copyright © 2018年 JFChen. All rights reserved.
*/

//一、深度测试
1、设置好一个平截头体（设置透视矩阵透视矩阵,比如glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);）。 那么深度值Z对应的应该就是 0.1 ～ 100，对应着z值的0～1。是线形对齐的。也就是说 0.1 对应的是0，100对应的是1.但其实不是的。 深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。

"glDepthFunc(GL_LESS)";
这个函数接受下面表格中的比较运算符：

函数    描述
GL_ALWAYS    永远通过深度测试
GL_NEVER    永远不通过深度测试
GL_LESS    在片段深度值小于缓冲的深度值时通过测试
GL_EQUAL    在片段深度值等于缓冲区的深度值时通过测试
GL_LEQUAL    在片段深度值小于等于缓冲区的深度值时通过测试
GL_GREATER    在片段深度值大于缓冲区的深度值时通过测试
GL_NOTEQUAL    在片段深度值不等于缓冲区的深度值时通过测试
GL_GEQUAL    在片段深度值大于等于缓冲区的深度值时通过测试

//二、模版测试
一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。

1）
"glStencilFunc(GLenum func, GLint ref, GLuint mask)"一共包含三个参数：

func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。
ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。
mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。

例子：
glStencilFunc(GL_EQUAL, 1, 0xFF)
这会告诉OpenGL，只要一个片段的模板值等于(GL_EQUAL)参考值1，片段将会通过测试并被绘制，否则会被丢弃。

2）
glStencilFunc仅仅描述了OpenGL应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要glStencilOp这个函数了

"glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)"一共包含三个选项，我们能够设定每个选项应该采取的行为：

sfail：模板测试失败时采取的行为。
dpfail：模板测试通过，但深度测试失败时采取的行为。
dppass：模板测试和深度测试都通过时采取的行为。
每个选项都可以选用以下的其中一种行为：

行为    描述
GL_KEEP    保持当前储存的模板值
GL_ZERO    将模板值设置为0
GL_REPLACE    将模板值设置为glStencilFunc函数设置的ref值
GL_INCR    如果模板值小于最大值则将模板值加1
GL_INCR_WRAP    与GL_INCR一样，但如果模板值超过了最大值则归零
GL_DECR    如果模板值大于最小值则将模板值减1
GL_DECR_WRAP    与GL_DECR一样，但如果模板值小于0则将其设置为最大值
GL_INVERT    按位翻转当前的模板缓冲值

3）
为物体创建轮廓的步骤如下：

在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。
渲染物体。
禁用模板写入以及深度测试。
将每个物体放大一点点。
使用一个不同的片段着色器，输出一个单独的（边框）颜色。
再次绘制物体，但只在它们片段的模板值不等于1时才绘制。
再次启用模板写入和深度测试。
这个过程将每个物体的片段的模板缓冲设置为1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。

通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。


//三、混合
要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。
但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：

先绘制所有不透明的物体。
对所有透明的物体排序。
按顺序绘制所有透明的物体。



//四、面剔除
把看不见的面剔除




//五、framebuffer

渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。

用于写入颜色值的颜色缓冲、用于写入深度信息的"深度缓冲"和允许我们根据一些条件丢弃特定片段的"模板缓冲"。'这些缓冲结合起来叫做帧缓冲(Framebuffer)'，它被储存在内存中
我们目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。
 

'unsigned int fbo;
'glGenFramebuffers(1, &fbo);
'glBindFramebuffer(GL_FRAMEBUFFER, fbo);

在绑定到GL_FRAMEBUFFER目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。我们也可以使用'GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER'，将一个帧缓冲分别绑定到读取目标或写入目标。
绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上。

//一个完整的帧缓冲需要满足以下的条件：
"附加至少一个缓冲（颜色、深度或模板缓冲）。
"至少有一个颜色附件(Attachment)。
"所有的附件都必须是完整的（保留了内存）。
"每个缓冲都应该有相同的样本数。

由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做"离屏渲染(Off-screen Rendering)"。
要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到0。

渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。

我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。

渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。

要想绘制场景到一个纹理上，我们需要采取以下的步骤：
'将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景
'绑定默认的帧缓冲
'绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。
/*
screenShader.use();
glBindVertexArray(quadVAO);
glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
glDrawArrays(GL_TRIANGLES, 0, 6);
*/

















